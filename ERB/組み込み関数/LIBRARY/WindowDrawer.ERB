
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
; 複数のウィンドウを管理し、まとめて描画するための関数群
;
;	関数名	:	WndMgr_～～(), FuncWndMgr_～～()
;
;	※ 要 TagSetText.ERB
; 
;--------------------------------
; 注意事項)
;	・@WndMgr_Display()の nDisplayWidth はヴァリアントの設定に応じて変更すること
; 
;	・ウィンドウは100個まで作成可能（WindowDrawer.ERHのDEF_WINDOW_DRAWER_MAX_WND_LENGTHで設定）
; 
;	・一画面に収まる程度のサイズでの使用を想定している
; 
;	・枠ありにする場合は、その分ウィンドウの大きさを増やすこと（縦:+2,横:+4）
; 
;	・また、太字などのフォント修飾を使用すると文字の横幅が少し増えるため、ウィンドウサイズには少し余裕を持たせると良い
; 
;	・枠無しの場合でも、描画の左位置を設定するために半角スペースを設定している。そのため枠無しウィンドウの左側に半角スペースが一文字設定される。
; 
;	・ウィンドウの背景は全て半角スペースのボタンとなっている。これはウィンドウが重なった際に、ウィンドウに隠れている下のウィンドウのボタンが押下できてしまう現象を防ぐため
;	　そのため、INPUTSなどの処理では、ウィンドウ枠内をクリックすると、半角スペースが入力されたとしてINPUTSを抜けてしまう。
;	　INPUTS使用時は半角スペースの入力を無効とし再入力させるなどして対応すること。
; 
;	・ウィンドウが重なる状態では、上にウィンドウが重なるウィンドウでは画像の描画が無効化される。
;	　これは下のウィンドウで描画される画像が、上のウィンドウを突きぬけてしまう現象を回避するための処置。
;	　複数行に跨る画像描画を禁止し、resourcesのcsv登録を一行単位で行うようにすれば現象は発生しなくなるが、画像登録の手間と現象によるデメリットを考慮し、仕様とした。
; 
;--------------------------------
; 使い方)
;	以下のような流れで複数のウィンドウを生成しまとめて描画する。
;	ウィンドウの領域が重なっていた場合、基本的には新しく生成したウィンドウが上になる。
;	ウィンドウ内に表示する文字列はタグ指定することで、色変更やボタン化を行える。タグ指定については TagSetText.ERB を参照。
;	----------------
;		ウィンドウ生成 → 行数を指定して文字列を設定 → 行数を指定して文字列を設定 → 行数を指定して文字列を設定
;		 → ウィンドウ生成 → 行数を指定して文字列を設定
;		 → 全てのウィンドウを描画
;		 → 生成したウィンドウを破棄
;	----------------
; 
;--------------------------------
; サンプル)
;	以下のコードは2つのウィンドウを描画するコードです
;		CALL WndMgr_CreateWindow( 0, 0, 0, 32, 10, 1 )			; ウィンドウを生成（ID=0, 左上Ｘ値=0, 左上Ｙ値=0, 幅=32, 高さ=10, 枠あり）
;		CALL WndMgr_TextSet( 0, 0, "ウィンドウ０" )				; 「ID=0」のウィンドウの 0 行目の文字列を "ウィンドウ１" に設定
;		CALL WndMgr_TextSet( 0, 1, "あいうえお" )				; 「ID=0」のウィンドウの 1 行目の文字列を "あいうえお" に設定
;		CALL WndMgr_CreateWindow( 1, 36, 2, 32, 10, 1 )			; ウィンドウを生成（ID=1, 左上Ｘ値=36, 左上Ｙ値=2, 幅=32, 高さ=10, 枠あり）
;		CALL WndMgr_TextSet( 1, 0, "ウィンドウ１" )				; 「ID=1」のウィンドウの 0 行目の文字列を "ウィンドウ２" に設定
;		CALL WndMgr_TextSet( 1, 1, "かきくけこ" )				; 「ID=1」のウィンドウの 1 行目の文字列を "かきくけこ" に設定
;		CALL WndMgr_DisplayAll()								; ウィンドウ０とウィンドウ１を描画する
;		CALL WndMgr_DestroyWindow( 0 )							; ウィンドウを破棄する
;		CALL WndMgr_DestroyWindow( 1 )							; ウィンドウを破棄する
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡


;================================================================
; 未生成のウィンドウIDを取得する
;--------------------------------
;--------------------------------
;[戻り値など]
;	RESULT:0	: 未生成（CREATEされていない）ウィンドウIDの内、最も若いIDを返す。
;				  未生成のウィンドウIDがない場合は -1 を返す
;================================================================
@WndMgr_VacantId()
#DIM nWndId

FOR nWndId, 0, DEF_WINDOW_DRAWER_MAX_WND_LENGTH
	CALL WndMgr_WindowMgrMain( "EXIST", nWndId, 0, "" )
	SIF RESULT == 0
		RETURN nWndId
NEXT

DEBUGPRINTFORML ★★★ Windowの領域に空きがありません
RETURN -1


;================================================================
; 生成済みのウィンドウIDのリストを取得する
;--------------------------------
;--------------------------------
;[戻り値など]
;	RESULT:0	: 生成済みのウィンドウIDの個数
;	RESULT:1~	: 生成済みのウィンドウIDのリスト
;================================================================
@WndMgr_CheckExistWindow()
#DIM nWndId
#DIM arrWndIdList, DEF_WINDOW_DRAWER_MAX_WND_LENGTH
#DIM nIdx

nIdx = 0
VARSET arrWndIdList, -1
FOR nWndId, 0, DEF_WINDOW_DRAWER_MAX_WND_LENGTH
	CALL WndMgr_WindowMgrMain( "EXIST", nWndId, 0, "" )
	IF RESULT == 1
		arrWndIdList:nIdx = nWndId
		nIdx += 1
	ENDIF
NEXT

VARSET RESULT, -1
ARRAYCOPY "arrWndIdList", "RESULT"
ARRAYSHIFT RESULT, 1, 0
RESULT:0 = nIdx

RETURN RESULT


;================================================================
; 表示中の有効なウィンドウに存在するボタン情報の取得/設定
;--------------------------------
;	strMode				: 処理モード（"GET"or"SET"）
;	arrButtonValue		: (REF) 表示中の有効なウィンドウに存在するボタンのボタン値
;	nButtonCount		: (REF) arrButtonValueの有効値数
;--------------------------------
;[戻り値など]
;	strMode="GET"指定した場合、「arrButtonValue,nButtonCount」に有効なボタンの情報が格納される
;================================================================
@WndMgr_ButtonInfo( strMode, arrButtonValue, nButtonCount )
#DIMS strMode
#DIMS REF arrButtonValue, 0
#DIM REF  nButtonCount

#DIMS arrButtonValueMem, 2000
#DIM  nButtonCountMem
#DIM  nLoop

SELECTCASE strMode
	CASE "GET"
		VARSET arrButtonValue, ""
		ARRAYCOPY "arrButtonValueMem", "arrButtonValue"
		nButtonCount = nButtonCountMem

	CASE "SET"
		VARSET arrButtonValueMem, ""
		nButtonCountMem = 0
			; 重複した値があるかもしれないので、チェックしながら記録
		FOR nLoop, 0, MIN( VARSIZE( "arrButtonValueMem" ), nButtonCount )
			LOCALS '= arrButtonValue:nLoop
			IF STRLENS(LOCALS) > 0
				IF FINDELEMENT(arrButtonValueMem, LOCALS, 0, VARSIZE( "arrButtonValueMem" ), 1) == -1
					arrButtonValueMem:nButtonCountMem '= LOCALS
					nButtonCountMem += 1
				ENDIF
			ENDIF
		NEXT
;			DEBUGPRINTFORML 　debug - WndMgr_ButtonInfo() 有効ボタンデータ({nButtonCountMem}個)：
;			DEBUGPRINTFORM 　　
;			FOR nLoop, 0, nButtonCountMem
;				DEBUGPRINTFORM [%arrButtonValueMem:nLoop%], 
;			NEXT
;			DEBUGPRINTFORML
ENDSELECT

RETURN 0


;================================================================
; 指定したウィンドウと描画領域が（一部でも）重なっているウィンドウのリストを取得する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	ARG:0		: 非表示のウィンドウは対象外にする
;--------------------------------
;[戻り値など]
;	RESULT:0	: ウィンドウIDの個数
;	RESULT:1~	: ウィンドウIDのリスト
;================================================================
@WndMgr_CheckOverlapWnd( nWndId, ARG:0 )
#DIM  nWndId

#DIM  nWndA_Left
#DIM  nWndA_Top
#DIM  nWndA_Rigth
#DIM  nWndA_Bottom

#DIM  nWndB_Left
#DIM  nWndB_Top
#DIM  nWndB_Rigth
#DIM  nWndB_Bottom

#DIM  arrWndIdList, DEF_WINDOW_DRAWER_MAX_WND_LENGTH
#DIM  nWndCount
#DIM  arrExistWndIdList, DEF_WINDOW_DRAWER_MAX_WND_LENGTH
#DIM  nExistWndCnt

#DIM  nLoop
#DIM  nCheck

CALL WndMgr_GetRectangle( nWndId )
nWndA_Left   = RESULT:0
nWndA_Top    = RESULT:1
nWndA_Rigth  = RESULT:0 + RESULT:2 - 1
nWndA_Bottom = RESULT:1 + RESULT:3 - 1

VARSET arrExistWndIdList, -1
CALL WndMgr_CheckExistWindow()
nExistWndCnt = RESULT:0
ARRAYCOPY "RESULT", "arrExistWndIdList"
ARRAYSHIFT arrExistWndIdList, -1, -1

nWndCount = 0
VARSET arrWndIdList, -1
FOR nLoop, 0, nExistWndCnt
	nCheck = arrExistWndIdList:nLoop
	SIF nCheck < 0
		CONTINUE
	IF ARG:0 == 1
			; 非表示ウィンドウは対象外
		CALL WndMgr_GetPropertyNum( nCheck, PropIdx_WndHidden )
		SIF RESULT == 1
			CONTINUE
	ENDIF
		; ウィンドウの表示位置とサイズを取得
	CALL WndMgr_GetRectangle( nCheck )
	nWndB_Left   = RESULT:0
	nWndB_Top    = RESULT:1
	nWndB_Rigth  = RESULT:0 + RESULT:2 - 1
	nWndB_Bottom = RESULT:1 + RESULT:3 - 1
		; ウィンドウＡの左端がウィンドウＢの右端よりも右なら重なっていない
		; ウィンドウＡの右端がウィンドウＢの左端よりも左なら重なっていない
		; ウィンドウＡの上端がウィンドウＢの下端よりも下なら重なっていない
		; ウィンドウＡの下端がウィンドウＢの上端よりも上なら重なっていない
	SIF nWndA_Left   > nWndB_Rigth
		CONTINUE
	SIF nWndA_Rigth  < nWndB_Left
		CONTINUE
	SIF nWndA_Top    > nWndB_Bottom
		CONTINUE
	SIF nWndA_Bottom < nWndB_Top
		CONTINUE
	arrWndIdList:nWndCount = nCheck
	nWndCount += 1
NEXT

VARSET RESULT, -1
ARRAYCOPY "arrWndIdList", "RESULT"
ARRAYSHIFT RESULT, 1, 0
RESULT:0 = nWndCount

RETURN RESULT


;================================================================
; ウィンドウが他ウィンドウの背後にあるかのプロパティ値をまとめて設定する
;--------------------------------
;[引数]
;	nWindowCnt				: ウィンドウ数
;	arrDisplayPriority		: 描画対象ウィンドウ（ウィンドウIDを配列で指定する。ここで指定した順番でウィンドウの描画が行われる）
;								※ 若い位置のウィンドウほど下になる
;--------------------------------
;[戻り値など]
;================================================================
@WndMgr_SetBehindProp( nWindowCnt, arrDisplayPriority )
#DIM  nWindowCnt
#DIM REF arrDisplayPriority, 0

#DIM  nWindowCnt_Mem					; 再チェック防止用の前回の対象ウィンドウ情報を保持する
#DIM  arrDisplayPriority_Mem, 1000		; 同上

#DIM  arrWndIdOverlap, 200
#DIM  nOverlapWndCount
#DIM  nTargetWndId

#DIM  nLoop
#DIM  nCheck

	; 対象ウィンドウ情報を前回と今回で比較（同じならチェックする必要はない）
IF nWindowCnt_Mem == nWindowCnt
	nCheck = 0
	FOR nLoop, 0, nWindowCnt
		IF arrDisplayPriority_Mem:nLoop != arrDisplayPriority:nLoop
			BREAK
		ENDIF
		nCheck += 1
	NEXT
		; 対象ウィンドウ情報を前回と今回で同じなら、何もせずに抜ける
	IF nCheck == nWindowCnt
		RETURN
	ENDIF
ENDIF

	; 全てのウィンドウの他ウィンドウの背後にあるかのプロパティ値をリセットする
FOR nLoop, 0, nWindowCnt
	CALL WndMgr_SetPropertyNum( arrDisplayPriority:nLoop, PropIdx_WndBehindWindow, 0 )
NEXT

	; 他ウィンドウの背後にあるかのチェック
FOR nLoop, 0, nWindowCnt
	nTargetWndId = arrDisplayPriority:nLoop
		; 重なっているウィンドウを取得
	VARSET arrWndIdOverlap, -1
	CALL WndMgr_CheckOverlapWnd( nTargetWndId, 1 )
	nOverlapWndCount = RESULT:0
	ARRAYCOPY "RESULT", "arrWndIdOverlap"
	ARRAYSHIFT arrWndIdOverlap, -1, -1
		; 重なっているウィンドウが、チェック対象ウィンドウよりも上に表示されるウィンドウかをチェックする
	FOR nCheck, 0, nOverlapWndCount
		LOCAL = FINDELEMENT( arrDisplayPriority, arrWndIdOverlap:nCheck )
		IF LOCAL > nLoop
			CALL WndMgr_SetPropertyNum( arrDisplayPriority:nLoop, PropIdx_WndBehindWindow, 1 )		; 上に重なっているウィンドウが存在するので、チェック対象ウィンドウは「他ウィンドウの背後にある」
			BREAK
		ENDIF
	NEXT
NEXT

	; 今回のチェック対象情報を記憶する
nWindowCnt_Mem = nWindowCnt
VARSET arrDisplayPriority_Mem, -1
ARRAYCOPY "arrDisplayPriority", "arrDisplayPriority_Mem"

RETURN


;================================================================
; 生成したウィンドウを描画する
;--------------------------------
;	nBtnIsNum				: ボタンを数値ボタンで表示するフラグ（0=文字列ボタン, 1=数値ボタン）
;================================================================
@WndMgr_DisplayAll( nBtnIsNum = 0 )
#DIM  nBtnIsNum

#DIM  nWindowCnt
#DIM  arrDisplayPriority, DEF_WINDOW_DRAWER_MAX_WND_LENGTH = -1
#DIM  nLoop
#DIM  nCheck

VARSET arrDisplayPriority, -1
CALL WndMgr_CheckExistWindow()
nWindowCnt = RESULT:0
ARRAYCOPY "RESULT", "arrDisplayPriority"
ARRAYSHIFT arrDisplayPriority, -1, -1

CALL WndMgr_Display( nWindowCnt, arrDisplayPriority, nBtnIsNum )


;================================================================
; 生成したウィンドウの内、指定したものだけを描画する
;--------------------------------
;	nWindowCnt				: ウィンドウ数
;	arrDisplayPriority		: 描画対象ウィンドウ（ウィンドウIDを配列で指定する。ここで指定した順番でウィンドウの描画が行われる）
;								※ 若い位置のウィンドウほど下になる
;	nBtnIsNum				: ボタンを数値ボタンで表示するフラグ（0=文字列ボタン, 1=数値ボタン）
;--------------------------------
;[戻り値など]
;================================================================
@WndMgr_Display( nWindowCnt, arrDisplayPriority, nBtnIsNum = 0 )
#LOCALSSIZE 10
#DIM  nWindowCnt
#DIM REF arrDisplayPriority, 0
#DIM  nBtnIsNum

SELECTCASE DEF_WINDOW_DRAWER_MODE
	CASE 0
		CALL WndMgr_Display_ModeHtml( nWindowCnt, arrDisplayPriority, nBtnIsNum )		; HTML命令使用版
	CASE 1
		CALL WndMgr_Display_ModePrint( nWindowCnt, arrDisplayPriority, nBtnIsNum )		; PRINT系命令使用版
ENDSELECT

RETURN


;================================================================
; 生成したウィンドウの内、指定したものだけを描画する
;	(HTML版)
;--------------------------------
;	nWindowCnt				: ウィンドウ数
;	arrDisplayPriority		: 描画対象ウィンドウ（ウィンドウIDを配列で指定する。ここで指定した順番でウィンドウの描画が行われる）
;								※ 若い位置のウィンドウほど下になる
;	nBtnIsNum				: ボタンを数値ボタンで表示するフラグ（0=文字列ボタン, 1=数値ボタン）
;--------------------------------
;[戻り値など]
;================================================================
@WndMgr_Display_ModeHtml( nWindowCnt, arrDisplayPriority, nBtnIsNum = 0 )
#LOCALSSIZE 10
#DIM  nWindowCnt
#DIM REF arrDisplayPriority, 0
#DIM  nBtnIsNum

#DIMS arrDisplayText, 200
#DIM  nLoop
#DIM  nWndId
#DIM  nWndLine
#DIM  nCheckLine
#DIM  nMaxLine

#DIM  nPosX
#DIM  nPosY
#DIM  nSizeW
#DIM  nSizeH
#DIM  nDisable

#DIMS strPrintText
#DIMS arrButtonValue, 1000
#DIM  nButtonCount

	; ウィンドウが背後にあるかどうかのプロパティ値を更新する
CALL WndMgr_SetBehindProp( nWindowCnt, arrDisplayPriority )

VARSET arrButtonValue, ""
nButtonCount = 0

nMaxLine = 0
VARSET arrDisplayText, ""

	; 全てのウィンドウの描画内容を１行ずつタグ指定文字列にする
FOR nLoop, 0, nWindowCnt
	nWndId = arrDisplayPriority:nLoop
	SIF nWndId < 0
		CONTINUE
	CALL WndMgr_Exist( nWndId )
	SIF RESULT == 0
		CONTINUE
	CALL WndMgr_GetPropertyNum( nWndId, PropIdx_WndHidden )
	SIF RESULT == 1
		CONTINUE

	CALL WndMgr_GetRectangle( nWndId )
	nPosX   = RESULT:0
	nPosY   = RESULT:1
	nSizeW  = RESULT:2
	nSizeH  = RESULT:3
	SIF nSizeW <= 0 || nSizeH <= 0
		CONTINUE

	CALL WndMgr_GetPropertyNum( nWndId, PropIdx_WndDisabled )
	nDisable = RESULT

		; 表示用テキストの生成
	CALL WndMgr_WindowMgrMain( "PRINT_TEXT_CREATE", nWndId, 0, "" )

		;DEBUGPRINTFORML check WndMgr_Display() PrintWndID={nWndId}
	FOR nWndLine, 0, nSizeH
		nCheckLine = nPosY + nWndLine
		SIF nCheckLine < 0
			CONTINUE
		CALL WndMgr_WindowMgrMain( "PRINT_TEXT_GET", nWndId, nWndLine, "" )
		strPrintText '= RESULTS:0
		arrDisplayText:nCheckLine += strPrintText
		nMaxLine = MAX( nMaxLine, nCheckLine )

			; ボタン情報の取得
		IF nDisable == 0
			CALL WndMgr_WindowMgrMain( "TEXT_GET", nWndId, nWndLine, "" )
			LOCAL = FuncTagSetText_GetButtonData( RESULTS )
			FOR LOCAL:1, 0, LOCAL:0
				arrButtonValue:nButtonCount '= RESULTS:(LOCAL:1)
				nButtonCount += 1
			NEXT
		ENDIF
	NEXT
NEXT

	; 全てのウィンドウの描画内容をまとめたタグ指定文字列を描画する
FOR nCheckLine, 0, nMaxLine + 1
	IF STRLENS( arrDisplayText:nCheckLine ) > 0
		HTML_PRINT @"<nobr>%arrDisplayText:nCheckLine%</nobr>"
	ELSE
		HTML_PRINT @"<nobr> </nobr>"
	ENDIF
		;DEBUGPRINTFORML debug - WndMgr_Display_ModeHtml() 「%arrDisplayText:nCheckLine%」
NEXT

	; 表示中の有効なボタン情報の登録
CALL WndMgr_ButtonInfo( "SET", arrButtonValue, nButtonCount )

RETURN


;================================================================
; 生成したウィンドウの内、指定したものだけを描画する
;--------------------------------
;	nWindowCnt				: ウィンドウ数
;	arrDisplayPriority		: 描画対象ウィンドウ（ウィンドウIDを配列で指定する。ここで指定した順番でウィンドウの描画が行われる）
;								※ 若い位置のウィンドウほど下になる
;	nBtnIsNum				: ボタンを数値ボタンで表示するフラグ（0=文字列ボタン, 1=数値ボタン）
;--------------------------------
;[戻り値など]
;================================================================
@WndMgr_Display_ModePrint( nWindowCnt, arrDisplayPriority, nBtnIsNum = 0 )
#LOCALSSIZE 10
#DIM  nWindowCnt
#DIM REF arrDisplayPriority, 0
#DIM  nBtnIsNum

#DIM  nDisplayWidth

#DIMS arrDisplayText, 200
#DIM  nLoop
#DIM  nWndId
#DIM  nWndLine
#DIM  nCheckLine
#DIM  nMaxLine

#DIM  nPosX
#DIM  nPosY
#DIM  nSizeW
#DIM  nSizeH
#DIM  nDisable

#DIMS strPrintText
#DIMS arrButtonValue, 1000
#DIM  nButtonCount

	; ウィンドウが背後にあるかどうかのプロパティ値を更新する
CALL WndMgr_SetBehindProp( nWindowCnt, arrDisplayPriority )

VARSET arrButtonValue, ""
nButtonCount = 0

nDisplayWidth = 2 * CLIENTWIDTH() / GETCONFIG("フォントサイズ")		; 1行に出力できる文字数（MSゴシックの半角）

nMaxLine = 0
VARSET arrDisplayText, ""

	; 全てのウィンドウの描画内容を１行ずつタグ指定文字列にする
FOR nLoop, 0, nWindowCnt
	nWndId = arrDisplayPriority:nLoop
	SIF nWndId < 0
		CONTINUE
	CALL WndMgr_Exist( nWndId )
	SIF RESULT == 0
		CONTINUE
	CALL WndMgr_GetPropertyNum( nWndId, PropIdx_WndHidden )
	SIF RESULT == 1
		CONTINUE

	CALL WndMgr_GetRectangle( nWndId )
	nPosX   = RESULT:0
	nPosY   = RESULT:1
	nSizeW  = RESULT:2
	nSizeH  = RESULT:3
	SIF nSizeW <= 0 || nSizeH <= 0
		CONTINUE

	CALL WndMgr_GetPropertyNum( nWndId, PropIdx_WndDisabled )
	nDisable = RESULT

		; 表示用テキストの生成
	CALL WndMgr_WindowMgrMain( "PRINT_TEXT_CREATE", nWndId, 0, "" )

		;DEBUGPRINTFORML check WndMgr_Display() PrintWndID={nWndId}
	FOR nWndLine, 0, nSizeH
		VARSET LOCALS, ""
		nCheckLine = nPosY + nWndLine
		SIF nCheckLine < 0
			CONTINUE
		IF nPosX >= 0
			CALLF TAG_PRINT_SHAPE( arrDisplayText:nCheckLine, nPosX, 1 )
			LOCALS:0 '= RESULTS:0
			CALLF TAG_PRINT_SHAPE( arrDisplayText:nCheckLine, nPosX + nSizeW, 0 )
			LOCALS:1 '= RESULTS:1
			CALL WndMgr_WindowMgrMain( "PRINT_TEXT_GET", nWndId, nWndLine, "" )
			CALLF TAG_PRINT_SHAPE( RESULTS, nSizeW, 1 )
			LOCALS:2 '= RESULTS:0
		ELSE
			LOCALS:0 '= ""
			CALLF TAG_PRINT_SHAPE( arrDisplayText:nCheckLine, MAX( 0, nPosX + nSizeW ), 0 )
			LOCALS:1 '= RESULTS:1
			IF nSizeW > nPosX
				CALL WndMgr_WindowMgrMain( "PRINT_TEXT_GET", nWndId, nWndLine, "" )
				CALLF TAG_PRINT_SHAPE( RESULTS, ABS( nPosX ), 0 )
				LOCALS:2 '= RESULTS:1
			ELSE
				LOCALS:2 '= ""
			ENDIF
		ENDIF
		arrDisplayText:nCheckLine '= LOCALS:0 + LOCALS:2 + LOCALS:1
		nMaxLine = MAX( nMaxLine, nCheckLine )
		strPrintText '= LOCALS:2

			; ボタン情報の取得
		IF nDisable == 0
			LOCAL = FuncTagSetText_GetButtonData( strPrintText )
			FOR LOCAL:1, 0, LOCAL:0
				arrButtonValue:nButtonCount '= RESULTS:(LOCAL:1)
				nButtonCount += 1
			NEXT
		ENDIF
	NEXT
NEXT

	; 全てのウィンドウの描画内容をまとめたタグ指定文字列を描画する
FOR nCheckLine, 0, nMaxLine + 1
	LOCALS '= TAG_PRINT_SHAPE( arrDisplayText:nCheckLine, nDisplayWidth, 1 )
	CALLF TAG_PRINT( LOCALS, (nBtnIsNum == 0 ? 0x01 # 0x05) )
NEXT

	; 表示中の有効なボタン情報の登録
CALL WndMgr_ButtonInfo( "SET", arrButtonValue, nButtonCount )

RETURN


;================================================================
; ウィンドウが存在するかどうか
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;--------------------------------
;[戻り値など]
;		RESULT:0	: 0=存在しない, 1=存在する
;================================================================
@WndMgr_Exist( nWndId )
#DIM  nWndId

SIF nWndId < 0 || nWndId >= DEF_WINDOW_DRAWER_MAX_WND_LENGTH
	RETURN 0
	; 指定したウィンドウ番号のウィンドウが生成済みかどうかをチェックする
CALL WndMgr_WindowMgrMain( "EXIST", nWndId, 0, "" )
RETURN RESULT


;================================================================
; ウィンドウを生成する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	nLocX		: ウィンドウ座標（左上Ｘ値）
;	nLocY		: ウィンドウ座標（左上Ｙ値）
;	nWidth		: ウィンドウサイズ（幅）※枠を使用する場合、偶数で指定すること
;	nHeigth		: ウィンドウサイズ（高さ）
;	nExFlag		: その他の設定
;					0x01 : 枠あり（太枠。枠の分だけ記述できる領域が小さくなるので注意すること）
;					0x02 : 枠あり（細枠。枠の分だけ記述できる領域が小さくなるので注意すること）
;							※ 0x03の場合は細枠になる
;--------------------------------
;================================================================
@WndMgr_CreateWindow( nWndId, nLocX, nLocY, nWidth, nHeigth, nExFlag )
#DIM  nWndId
#DIM  nLocX
#DIM  nLocY
#DIM  nWidth
#DIM  nHeigth
#DIM  nExFlag

#DIM  nBorder

	; 指定したウィンドウ番号のウィンドウが生成済みの場合はエラーにする
CALL WndMgr_Exist( nWndId )
IF RESULT == 1
	THROW WndMgr_CreateWindow() : ウィンドウ（nWndId={nWndId}）は生成済みです
ENDIF

	; ウィンドウを生成する
IF (nExFlag & 0x02)
	nBorder = 2
ELSEIF (nExFlag & 0x01)
	nBorder = 1
ELSE
	nBorder = 0
ENDIF
CALL WndMgr_WindowMgrMain( "CREATE", nWndId, 0, @"{nLocX},{nLocY},{nWidth},{nHeigth},{nBorder}" )

RETURN


;================================================================
; ウィンドウを破棄する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ, -1=生成済みの全ウィンドウ対象）
;--------------------------------
;================================================================
@WndMgr_DestroyWindow( nWndId )
#DIM  nWndId

#DIM  arrWndIdList, DEF_WINDOW_DRAWER_MAX_WND_LENGTH
#DIM  nExistWndCnt
#DIM  nLoop

IF nWndId == -1
	CALL WndMgr_CheckExistWindow()
	nExistWndCnt = RESULT:0
	ARRAYSHIFT RESULT, -1, -1
	ARRAYCOPY "RESULT", "arrWndIdList"
ELSE
	nExistWndCnt = 1
	arrWndIdList:0 = nWndId
ENDIF

FOR nLoop, 0, nExistWndCnt
		;--------------------------------
		;※ 初期化としても使うかもしれないのでこのエラーチェックはコメントアウト
		;	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
		;	CALL WndMgr_Exist( arrWndIdList:nLoop )
		;	IF RESULT == 0
		;		THROW CREATE_WINDOW() : ウィンドウ（nWndId={arrWndIdList:nLoop}）は未生成です
		;	ENDIF
		;--------------------------------

		; ウィンドウを破棄する
	CALL WndMgr_WindowMgrMain( "DESTROY", arrWndIdList:nLoop, 0, "" )
NEXT

RETURN


;================================================================
; ウィンドウの属性とテキストを初期化する
;	※ ウィンドウの位置,サイズ,枠設定は変化しない
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ, -1=生成済みの全ウィンドウ対象）
;--------------------------------
;================================================================
@WndMgr_ResetWindow( nWndId )
#DIM  nWndId

#DIM  arrWndIdList, DEF_WINDOW_DRAWER_MAX_WND_LENGTH
#DIM  nExistWndCnt
#DIM  nLoop

IF nWndId == -1
	CALL WndMgr_CheckExistWindow()
	nExistWndCnt = RESULT:0
	ARRAYSHIFT RESULT, -1, -1
	ARRAYCOPY "RESULT", "arrWndIdList"
ELSE
	nExistWndCnt = 1
	arrWndIdList:0 = nWndId
ENDIF

FOR nLoop, 0, nExistWndCnt
		;--------------------------------
		;※ 初期化としても使うかもしれないのでこのエラーチェックはコメントアウト
		;	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
		;	CALL WndMgr_Exist( arrWndIdList:nLoop )
		;	IF RESULT == 0
		;		THROW CREATE_WINDOW() : ウィンドウ（nWndId={arrWndIdList:nLoop}）は未生成です
		;	ENDIF
		;--------------------------------

		; ウィンドウの属性とテキストを初期化
	CALL WndMgr_WindowMgrMain( "RESET", arrWndIdList:nLoop, 0, "" )
NEXT

RETURN


;================================================================
; ウィンドウのタイトルを設定する
;	※ タイトルは枠線表示設定時に、右上の枠線上に表示される（┌タイトル────┐）
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	strText		: 設定する文字列（タグ指定文字列(TagSetText.ERBを参照)で指定可能）
;--------------------------------
;[戻り値など]
;================================================================
@WndMgr_WindowTitle( nWndId, strText )
#DIM  nWndId
#DIMS strText

	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
CALL WndMgr_Exist( nWndId )
IF RESULT == 0
	THROW WndMgr_TextSet() : ウィンドウ（nWndId={nWndId}）は未生成です
ENDIF

	; ウィンドウのタイトルを設定する
CALL WndMgr_WindowMgrMain( "TITLE", nWndId, 0, strText )

RETURN


;================================================================
; ウィンドウに表示する文字列を設定する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	nLine		: 文字列を設定する行位置
;	strText		: 設定する文字列（タグ指定文字列(TagSetText.ERBを参照)で指定可能）
;--------------------------------
;================================================================
@WndMgr_TextSet( nWndId, nLine, strText )
#DIM  nWndId
#DIM  nLine
#DIMS strText

	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
CALL WndMgr_Exist( nWndId )
IF RESULT == 0
	THROW WndMgr_TextSet() : ウィンドウ（nWndId={nWndId}）は未生成です
ENDIF

	; ウィンドウに表示する文字列を設定する
CALL WndMgr_WindowMgrMain( "TEXT_SET", nWndId, nLine, strText )

RETURN


;================================================================
; ウィンドウに表示する文字列を追加する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	nLine		: 文字列を設定する行位置
;	strText		: 設定する文字列（タグ指定文字列(TagSetText.ERBを参照)で指定可能）
;--------------------------------
;================================================================
@WndMgr_TextAdd( nWndId, nLine, strText )
#DIM  nWndId
#DIM  nLine
#DIMS strText

	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
CALL WndMgr_Exist( nWndId )
IF RESULT == 0
	THROW WndMgr_TextSet() : ウィンドウ（nWndId={nWndId}）は未生成です
ENDIF

	; ウィンドウに表示する文字列を設定する
CALL WndMgr_WindowMgrMain( "TEXT_ADD", nWndId, nLine, strText )

RETURN


;================================================================
; ウィンドウに設定されている文字列を全てクリアする
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ, -1=生成済みの全ウィンドウ対象）
;--------------------------------
;================================================================
@WndMgr_TextClear( nWndId )
#DIM  nWndId

#DIM  arrWndIdList, DEF_WINDOW_DRAWER_MAX_WND_LENGTH
#DIM  nExistWndCnt
#DIM  nLoop

IF nWndId == -1
	CALL WndMgr_CheckExistWindow()
	nExistWndCnt = RESULT:0
	ARRAYSHIFT RESULT, -1, -1
	ARRAYCOPY "RESULT", "arrWndIdList"
ELSE
	nExistWndCnt = 1
	arrWndIdList:0 = nWndId
ENDIF

FOR nLoop, 0, nExistWndCnt
		;--------------------------------
		;※ 初期化としても使うかもしれないのでこのエラーチェックはコメントアウト
		;	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
		;	CALL WndMgr_Exist( arrWndIdList:nLoop )
		;	IF RESULT == 0
		;		THROW CREATE_WINDOW() : ウィンドウ（nWndId={arrWndIdList:nLoop}）は未生成です
		;	ENDIF
		;--------------------------------

		; ウィンドウに設定されている文字列を全てクリア
	CALL WndMgr_WindowMgrMain( "TEXT_CLEAR", arrWndIdList:nLoop, 0, "" )
NEXT

RETURN


;================================================================
; ウィンドウの表示位置,サイズなどを変更する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	nLocX		: ウィンドウ座標（左上Ｘ値）
;	nLocY		: ウィンドウ座標（左上Ｙ値）
;	nWidth		: ウィンドウサイズ（幅） ※枠を使用する場合、偶数で指定すること
;	nHeigth		: ウィンドウサイズ（高さ）
;	nExFlag		: その他の設定
;					0x01 : 枠あり（太枠。枠の分だけ記述できる領域が小さくなるので注意すること）
;					0x02 : 枠あり（細枠。枠の分だけ記述できる領域が小さくなるので注意すること）
;							※ 0x03の場合は細枠になる
;--------------------------------
;================================================================
@WndMgr_Rectangle( nWndId, nLocX, nLocY, nWidth, nHeigth, nExFlag )
#DIM  nWndId
#DIM  nLocX
#DIM  nLocY
#DIM  nWidth
#DIM  nHeigth
#DIM  nExFlag

#DIM  nBorder

	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
CALL WndMgr_Exist( nWndId )
IF RESULT == 0
	THROW WndMgr_Rectangle() : ウィンドウ（nWndId={nWndId}）は未生成です
ENDIF

	; ウィンドウの表示位置などを再設定する
IF (nExFlag & 0x02)
	nBorder = 2
ELSEIF (nExFlag & 0x01)
	nBorder = 1
ELSE
	nBorder = 0
ENDIF
CALL WndMgr_WindowMgrMain( "RECTANGLE", nWndId, 0, @"{nLocX},{nLocY},{nWidth},{nHeigth},{nBorder}" )

RETURN


;================================================================
; ウィンドウの表示位置を変更する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	nLocX		: ウィンドウ座標（左上Ｘ値）
;	nLocY		: ウィンドウ座標（左上Ｙ値）
;--------------------------------
;================================================================
@WndMgr_Move( nWndId, nLocX, nLocY )
#DIM  nWndId
#DIM  nLocX
#DIM  nLocY

	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
CALL WndMgr_Exist( nWndId )
IF RESULT == 0
	THROW WndMgr_Move() : ウィンドウ（nWndId={nWndId}）は未生成です
ENDIF

	; 表示位置変更
CALL WndMgr_WindowMgrMain( "MOVE", nWndId, 0, @"{nLocX},{nLocY}" )

RETURN


;================================================================
; ウィンドウの属性を変更する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ, -1=生成済みの全ウィンドウ対象）
;	ARGS:0		: 設定する属性名称
;	ARG:0		: 設定値
;					ARGS="Border"			: ARG … 0=枠無し, 1=太枠, 2=細枠, 
;					ARGS="Disabled"			: ARG … 0=ウィンドウ有効化, 1=ウィンドウ無効化（灰色表示、タグ無効化）
;					ARGS="BorderColor"		: ARG … ウィンドウの枠の色を指定する（-1で指定なし）
;					ARGS="Hide"				: ARG … 非表示フラグ（0=表示する, 1=非表示, ）
;					ARGS="LogButton"		: ARG … ログボタン有効化（0=無効化, 1=有効化, ）
;--------------------------------
;================================================================
@WndMgr_Attribute( nWndId, ARGS, ARG )
#DIM  nWndId
#DIM  nExFlag

#DIM  nPropIndex, 5
#DIM  nPropValue, 5

#DIM  arrWndIdList, DEF_WINDOW_DRAWER_MAX_WND_LENGTH
#DIM  nExistWndCnt
#DIM  nLoop

VARSET nPropIndex, -1
VARSET nPropValue, -1
SELECTCASE ARGS
	CASE "Border"
		nPropIndex:0 = PropIdx_WndBorder
		nPropValue:0 = ARG
	CASE "Disabled"
		nPropIndex:0 = PropIdx_WndDisabled
		nPropValue:0 = ARG
	CASE "BorderColor"
		nPropIndex:0 = PropIdx_WndBorderColor
		nPropValue:0 = ARG
		nPropIndex:1 = PropIdx_WndBorderColorSet
		nPropValue:1 = (ARG == -1 ? 0 # 1)
	CASE "Hide"
		nPropIndex:0 = PropIdx_WndHidden
		nPropValue:0 = ARG
	CASE "LogButton"
		nPropIndex:0 = PropIdx_WndLogButton
		nPropValue:0 = ARG
	CASEELSE
		THROW WndMgr_Attribute() : 属性名称が不正です(%ARGS%)
ENDSELECT

IF nWndId == -1
	CALL WndMgr_CheckExistWindow()
	nExistWndCnt = RESULT:0
	ARRAYSHIFT RESULT, -1, -1
	ARRAYCOPY "RESULT", "arrWndIdList"
ELSE
	nExistWndCnt = 1
	arrWndIdList:0 = nWndId
ENDIF

FOR nLoop, 0, nExistWndCnt
		; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
	CALL WndMgr_Exist( arrWndIdList:nLoop )
	IF RESULT == 0
		THROW WndMgr_Attribute() : ウィンドウ（nWndId={arrWndIdList:nLoop}）は未生成です
	ENDIF

		; 設定反映
	FOR LOCAL, 0, 5
		SIF nPropIndex:(LOCAL) == -1
			CONTINUE
		CALL WndMgr_WindowMgrMain( "PROPERTY_NUM_SET", arrWndIdList:nLoop, nPropIndex:(LOCAL), TOSTR( nPropValue:(LOCAL) ) )
	NEXT
NEXT

RETURN


;================================================================
; ウィンドウの表示位置、サイズを取得する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	nPropIdx	: 取得したいプロパティIndex値（WindowDrawer.ERH参照）
;--------------------------------
;[戻り値など]
;		RESULT:0	: ウィンドウ座標Ｘ値
;		RESULT:1	: ウィンドウ座標Ｙ値
;		RESULT:2	: ウィンドウ幅
;		RESULT:3	: ウィンドウ高さ
;		RESULT:4	: ウィンドウ幅  (クライアント領域)
;		RESULT:5	: ウィンドウ高さ(クライアント領域)
;		RESULT:6	: 枠設定（0=枠無し, 1=枠あり, 2=枠あり(細枠), ）
;================================================================
@WndMgr_GetRectangle( nWndId )
#DIM  nWndId
#DIM  nPropIdx

	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
CALL WndMgr_Exist( nWndId )
IF RESULT == 0
	THROW WndMgr_Move() : ウィンドウ（nWndId={nWndId}）は未生成です
ENDIF

	; 設定取得
RESULT:0 = m_arrWndPropN:nWndId:PropIdx_WndPosX
RESULT:1 = m_arrWndPropN:nWndId:PropIdx_WndPosY
RESULT:2 = m_arrWndPropN:nWndId:PropIdx_WndWidth
RESULT:3 = m_arrWndPropN:nWndId:PropIdx_WndHeight
RESULT:4 = m_arrWndPropN:nWndId:PropIdx_WndClientWidth
RESULT:5 = m_arrWndPropN:nWndId:PropIdx_WndClientHeight
RESULT:6 = m_arrWndPropN:nWndId:PropIdx_WndBorder

RETURN RESULT


;================================================================
; ウィンドウに設定されているボタン情報を取得する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;--------------------------------
;[戻り値など]
;		RESULT:0	: ボタン数
;		RESULTS:0~	: ボタンのボタン値
;================================================================
@WndMgr_GetButtonData( nWndId )
#DIM  nWndId

#DIMS arrButtonValue, 1000
#DIM  nButtonCount
#DIM  nSizeH
#DIM  nLoop
#DIM  nWndLine

	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
CALL WndMgr_Exist( nWndId )
IF RESULT == 0
	THROW WndMgr_Move() : ウィンドウ（nWndId={nWndId}）は未生成です
ENDIF

	; 設定取得
CALL WndMgr_GetPropertyNum( nWndId, PropIdx_WndHeight )
nSizeH  = RESULT

VARSET arrButtonValue, ""
nButtonCount = 0

FOR nWndLine, 0, nSizeH
	CALL WndMgr_WindowMgrMain( "TEXT_GET", nWndId, nWndLine, "" )
	LOCAL = FuncTagSetText_GetButtonData( RESULTS )
	FOR nLoop, 0, LOCAL:0
		arrButtonValue:nButtonCount '= RESULTS:nLoop
		nButtonCount += 1
	NEXT
NEXT

VARSET RESULTS, ""
ARRAYCOPY "arrButtonValue", "RESULTS"
RETURN nButtonCount


;================================================================
; ウィンドウのプロパティ設定を取得する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	nPropIdx	: 対象のプロパティIndex値（WindowDrawer.ERH参照）
;--------------------------------
;[戻り値など]
;	RESULT:0	: 指定したプロパティ値
;================================================================
@WndMgr_GetPropertyNum( nWndId, nPropIdx )
#DIM  nWndId
#DIM  nPropIdx

	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
CALL WndMgr_Exist( nWndId )
IF RESULT == 0
	THROW WndMgr_Move() : ウィンドウ（nWndId={nWndId}）は未生成です
ENDIF

	; 設定取得
CALL WndMgr_WindowMgrMain( "PROPERTY_NUM_GET", nWndId, nPropIdx )

RETURN RESULT


;================================================================
; ウィンドウのプロパティ設定を取得する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	nPropIdx	: 対象のプロパティIndex値（WindowDrawer.ERH参照）
;--------------------------------
;[戻り値など]
;	RESULT:0	: 指定したプロパティ値
;================================================================
@WndMgr_GetPropertyStr( nWndId, nPropIdx )
#DIM  nWndId
#DIM  nPropIdx

	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
CALL WndMgr_Exist( nWndId )
IF RESULT == 0
	THROW WndMgr_Move() : ウィンドウ（nWndId={nWndId}）は未生成です
ENDIF

	; 設定取得
CALL WndMgr_WindowMgrMain( "PROPERTY_STR_GET", nWndId, nPropIdx )

RESULTS '= RESULTS
RETURN


;================================================================
; ウィンドウのプロパティ設定を変更する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	nPropIdx	: 対象のプロパティIndex値（WindowDrawer.ERH参照）
;	ARG:0		: 設定値
;--------------------------------
;[戻り値など]
;	RESULT:0	: 指定したプロパティ値
;================================================================
@WndMgr_SetPropertyNum( nWndId, nPropIdx, ARG )
#DIM  nWndId
#DIM  nPropIdx

	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
CALL WndMgr_Exist( nWndId )
IF RESULT == 0
	THROW WndMgr_Move() : ウィンドウ（nWndId={nWndId}）は未生成です
ENDIF

	; 設定取得
CALL WndMgr_WindowMgrMain( "PROPERTY_NUM_SET", nWndId, nPropIdx, TOSTR( ARG ) )

RETURN


;================================================================
; ウィンドウのプロパティ設定を変更する
;--------------------------------
;[引数]
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	nPropIdx	: 対象のプロパティIndex値（WindowDrawer.ERH参照）
;	ARGS:0		: 設定値
;--------------------------------
;[戻り値など]
;	RESULT:0	: 指定したプロパティ値
;================================================================
@WndMgr_SetPropertyStr( nWndId, nPropIdx, ARGS )
#DIM  nWndId
#DIM  nPropIdx

	; 指定したウィンドウ番号のウィンドウが未生成の場合はエラーにする
CALL WndMgr_Exist( nWndId )
IF RESULT == 0
	THROW WndMgr_Move() : ウィンドウ（nWndId={nWndId}）は未生成です
ENDIF

	; 設定取得
CALL WndMgr_WindowMgrMain( "PROPERTY_STR_SET", nWndId, nPropIdx, ARGS )

RETURN


;================================================================
;【内部処理用】
; ウィンドウの管理
;--------------------------------
;[引数]
;	strMode		: 処理内容
;					"EXIST"				: ウィンドウが生成されているか確認する
;					"CREATE"			: ウィンドウの生成
;					"DESTROY"			: ウィンドウの破棄
;					"MOVE"				: ウィンドウの位置を変更する
;					"RECTANGLE"			: ウィンドウの表示位置などを再設定する
;					"RESET"				: ウィンドウの属性と、テキストの初期化
;					"PROPERTY_NUM_GET"	: ウィンドウのプロパティ情報を取得する
;					"PROPERTY_NUM_SET"	: ウィンドウのプロパティ情報を設定する
;					"PROPERTY_STR_GET"	: ウィンドウのプロパティ情報を取得する
;					"PROPERTY_STR_SET"	: ウィンドウのプロパティ情報を設定する
;					"TEXT_CLEAR"		: ウィンドウに登録された文字列をすべてクリアする
;					"TEXT_SET"			: ウィンドウの指定した行位置に文字列を設定する
;					"TEXT_ADD"			: ウィンドウの指定した行位置に文字列を追加する
;					"TEXT_GET"			: ウィンドウの指定した行位置に設定されている文字列を取得する（表示用ではない文字列）
;					"PRINT_TEXT_CREATE"	: 表示用の文字列を生成する（"PRINT_TEXT_GET"で取得できるのは、ここで生成した文字列）
;					"PRINT_TEXT_GET"	: ウィンドウの指定した行位置の表示用の文字列を取得する
;					"TITLE"				: ウィンドウのタイトルを設定する          （枠あり時のみ有効）
;	nWndId		: ウィンドウＩＤ（0~=対象ウィンドウ）
;	ARG:0		: 処理内容によって変化
;	ARGS:0		: 処理内容によって変化
;--------------------------------
; 処理内容ごとの ARG:0,ARGS:0 の内容
;	strMode = "EXIST", "DESTROY"
;		ARG:0	: 未使用
;		ARGS:0	: 未使用
;
;	strMode = "CREATE", "RECTANGLE"
;		ARG:0	: 未使用
;		ARGS:0	: ウィンドウ情報をCSV形式で記述した文字列
;					（"ウィンドウ座標Ｘ値", "ウィンドウ座標Ｙ値", "ウィンドウ幅", "ウィンドウ高さ", "枠設定(0=枠無し, 1=枠あり, 2=枠あり(細枠), )" ）
;
;	strMode = "PROPERTY_NUM_GET", "PROPERTY_NUM_SET", "PROPERTY_STR_GET", "PROPERTY_STR_SET"
;		ARG:0	: 取得したいプロパティIndex値（WindowDrawer.ERH参照）
;		ARGS:0	: 設定値
;
;	strMode = "TEXT_SET", "TEXT_ADD"
;		ARG:0	: 文字列を設定する行位置
;		ARGS:0	: 設定する文字列
;
;	strMode = "TEXT_CLEAR"
;		ARG:0	: 未使用
;		ARGS:0	: 未使用
;
;	strMode = "PRINT_TEXT_GET"
;		ARG:0	: 取得する行位置
;		ARGS:0	: 未使用
;
;	strMode = "PRINT_TEXT_CREATE", "RESET"
;		ARG:0	: 未使用
;		ARGS:0	: 未使用
;--------------------------------
;[戻り値など]
;	strMode = "EXIST"の場合
;		RESULT:0	: 0=ウィンドウが生成されていない, 1=ウィンドウが生成されている
;
;	strMode = "PRINT_TEXT_GET"の場合
;		RESULTS:0	: 指定した行位置に設定されている文字列
;
;	strMode = "PROPERTY_NUM_GET"の場合
;		RESULT:0	: 指定したプロパティ値
;================================================================
@WndMgr_WindowMgrMain( strMode, nWndId, ARG, ARGS )
#LOCALSIZE 1000
#LOCALSSIZE 20
#DIMS DYNAMIC strMode
#DIM DYNAMIC  nWndId

#DIM DYNAMIC  nLoop
#DIM nWndTextLen = -1
#DIM nWndInfoLen = -1

IF nWndTextLen == -1
	VARSIZE m_arrWndText
	nWndTextLen = RESULT:1
ENDIF
IF nWndInfoLen == -1
	VARSIZE m_arrWndPropN
	nWndInfoLen = RESULT:1
ENDIF

SELECTCASE strMode
	CASE "CREATE"
		m_arrWndExsit:nWndId:0 = 1
		m_arrWndTitle:nWndId:0 '= ""
			; プロパティ値のリセット
		FOR nLoop, 0, nWndInfoLen
			m_arrWndPropN:nWndId:nLoop = 0
		NEXT
			; 登録テキストのリセット
		FOR nLoop, 0, nWndTextLen
			m_arrWndText:nWndId:nLoop '= ""
			m_arrWndTextPrint:nWndId:nLoop '= ""
		NEXT
			; 表示テキスト生成済みフラグ解除
		m_arrWndSetTextPrint:nWndId:0 = 0
			; 表示位置などの設定
		CALL WndMgr_WindowMgrMain( "RECTANGLE", nWndId, ARG, ARGS )

	CASE "DESTROY"
		m_arrWndExsit:nWndId:0 = 0
		m_arrWndTitle:nWndId:0 '= ""
			; プロパティ値のリセット
		FOR nLoop, 0, nWndInfoLen
			m_arrWndPropN:nWndId:nLoop = 0
		NEXT
			; 登録テキストのリセット
		FOR nLoop, 0, nWndTextLen
			m_arrWndText:nWndId:nLoop '= ""
			m_arrWndTextPrint:nWndId:nLoop '= ""
		NEXT
			; 表示テキスト生成済みフラグ解除
		m_arrWndSetTextPrint:nWndId:0 = 0

	CASE "RECTANGLE"
			; 表示位置などの設定
		VARSET LOCALS, ""
		SPLIT ARGS, ",", LOCALS
		FOR nLoop, 0, 5
			IF ISNUMERIC( LOCALS:nLoop ) == 0
				THROW WndMgr_WindowMgrMain() : 設定内容が不正です（strMode=%strMode%, ARGS=%ARGS%）
			ENDIF
		NEXT
		m_arrWndPropN:nWndId:PropIdx_WndPosX   = TOINT( LOCALS:0 )
		m_arrWndPropN:nWndId:PropIdx_WndPosY   = TOINT( LOCALS:1 )
		m_arrWndPropN:nWndId:PropIdx_WndWidth  = TOINT( LOCALS:2 )
		m_arrWndPropN:nWndId:PropIdx_WndHeight = TOINT( LOCALS:3 )
		m_arrWndPropN:nWndId:PropIdx_WndBorder = TOINT( LOCALS:4 )
		m_arrWndPropN:nWndId:PropIdx_WndClientWidth  = m_arrWndPropN:nWndId:PropIdx_WndWidth  - (m_arrWndPropN:nWndId:PropIdx_WndBorder == 0 ? 0 # 4)
		m_arrWndPropN:nWndId:PropIdx_WndClientHeight = m_arrWndPropN:nWndId:PropIdx_WndHeight - (m_arrWndPropN:nWndId:PropIdx_WndBorder == 0 ? 0 # 2)
			; 表示テキスト生成済みフラグ解除
		m_arrWndSetTextPrint:nWndId:0 = 0

	CASE "MOVE"
		VARSET LOCALS, ""
		SPLIT ARGS, ",", LOCALS
		FOR nLoop, 0, 2
			IF ISNUMERIC( LOCALS:nLoop ) == 0
				THROW WndMgr_WindowMgrMain() : 設定内容が不正です（strMode=%strMode%, ARGS=%ARGS%）
			ENDIF
		NEXT
		m_arrWndPropN:nWndId:PropIdx_WndPosX   = TOINT( LOCALS:0 )
		m_arrWndPropN:nWndId:PropIdx_WndPosY   = TOINT( LOCALS:1 )

	CASE "RESET"
			; プロパティ値のリセット（表示位置と枠の設定を除く）
		FOR nLoop, 0, nWndInfoLen
			SELECTCASE nLoop
				CASE PropIdx_WndPosX, PropIdx_WndPosY, PropIdx_WndWidth, PropIdx_WndHeight, PropIdx_WndClientWidth, PropIdx_WndClientHeight, PropIdx_WndBorder
				CASEELSE
					m_arrWndPropN:nWndId:nLoop = 0
			ENDSELECT
		NEXT
			; 登録テキストのリセット
		FOR nLoop, 0, nWndTextLen
			m_arrWndText:nWndId:nLoop '= ""
			m_arrWndTextPrint:nWndId:nLoop '= ""
		NEXT
			; 表示テキスト生成済みフラグ解除
		m_arrWndSetTextPrint:nWndId:0 = 0
		m_arrWndTitle:nWndId:0 '= ""

	CASE "PROPERTY_NUM_GET"
		RESULT:0 = m_arrWndPropN:nWndId:(ARG)
		RETURN RESULT:0

	CASE "PROPERTY_NUM_SET"
		m_arrWndPropN:nWndId:(ARG) = TOINT( ARGS )
		IF ARG == PropIdx_WndBorder
			m_arrWndPropN:nWndId:PropIdx_WndClientWidth  = m_arrWndPropN:nWndId:PropIdx_WndWidth  - (m_arrWndPropN:nWndId:PropIdx_WndBorder == 0 ? 0 # 4)
			m_arrWndPropN:nWndId:PropIdx_WndClientHeight = m_arrWndPropN:nWndId:PropIdx_WndHeight - (m_arrWndPropN:nWndId:PropIdx_WndBorder == 0 ? 0 # 2)
		ENDIF
			; 表示テキスト生成済みフラグ解除
		m_arrWndSetTextPrint:nWndId:0 = 0

	CASE "PROPERTY_STR_GET"
		RESULTS:0 '= m_arrWndPropS:nWndId:(ARG)
		RETURN

	CASE "PROPERTY_STR_SET"
		m_arrWndPropS:nWndId:(ARG) '= ARGS

	CASE "TEXT_CLEAR"
			; 登録テキストのリセット
		FOR nLoop, 0, nWndTextLen
			m_arrWndText:nWndId:nLoop '= ""
			m_arrWndTextPrint:nWndId:nLoop '= ""
		NEXT
			; 表示テキスト生成済みフラグ解除
		m_arrWndSetTextPrint:nWndId:0 = 0

	CASE "TEXT_SET"
		m_arrWndText:nWndId:(ARG) '= ARGS
			; 表示テキスト生成済みフラグ解除
		m_arrWndSetTextPrint:nWndId:0 = 0

	CASE "TEXT_ADD"
		m_arrWndText:nWndId:(ARG) '= m_arrWndText:nWndId:(ARG) + ARGS
			; 表示テキスト生成済みフラグ解除
		m_arrWndSetTextPrint:nWndId:0 = 0

	CASE "TEXT_GET"
		RESULTS:0 '= m_arrWndText:nWndId:(ARG)
		RETURN

	CASE "PRINT_TEXT_CREATE"
		IF m_arrWndSetTextPrint:nWndId:0 == 0
			CALL WndMgr_CreatePrintText( nWndId )		; 表示用テキストの生成
			m_arrWndSetTextPrint:nWndId:0 = 1
		ENDIF
		RETURN

	CASE "PRINT_TEXT_GET"
			; 表示用テキストが未生成の場合、生成する（※"PRINT_TEXT_CREATE"時の処理）
		IF m_arrWndSetTextPrint:nWndId:0 == 0
			CALL WndMgr_CreatePrintText( nWndId )		; 表示用テキストの生成
			m_arrWndSetTextPrint:nWndId:0 = 1
		ENDIF
		RESULTS:0 '= m_arrWndTextPrint:nWndId:(ARG)
		RETURN

	CASE "TITLE"
		m_arrWndTitle:nWndId:0 '= ARGS
			; 表示テキスト生成済みフラグ解除
		m_arrWndSetTextPrint:nWndId:0 = 0

	CASE "EXIST"
		RESULT:0 = m_arrWndExsit:nWndId:0
		RETURN RESULT:0

	CASEELSE
		DEBUGPRINTFORML ★★★ WndMgr_WindowMgrMain() : 処理内容の指定が不正です（strMode=%strMode%）

ENDSELECT

RETURN


;================================================================
;【内部処理用】
; 実際に表示する整形済みのテキストを作成する
;--------------------------------
;[引数]
;	nWndId						: ウィンドウＩＤ（0～9を指定する）
;--------------------------------
;================================================================
@WndMgr_CreatePrintText( nWndId )
#DIM  nWndId

SELECTCASE DEF_WINDOW_DRAWER_MODE
	CASE 0
		CALL WndMgr_CreatePrintText_Html( nWndId )
	CASE 1
		CALL WndMgr_CreatePrintText_Print( nWndId )
ENDSELECT

RETURN


;================================================================
;【内部処理用】
; 実際に表示する整形済みのテキストを作成する
;--------------------------------
;[引数]
;	nWndId						: ウィンドウＩＤ（0～9を指定する）
;--------------------------------
;================================================================
@WndMgr_CreatePrintText_Html( nWndId )
#DIM  nWndId

#DIMS arrWndTextBuf, 100

#DIMS arrBorderText, 8		; 左上, 上, 右上, 左下, 下, 右下, 左, 右, 
#DIMS arrBorderColor, 2
#DIMS strInvlidColorText = "@C:0x333333@"

#DIMS arrPaddingSpace				; 後のウィンドウを目隠しするためのスペース埋め
#DIMS arrWndText_LineStartText, 3	; 0:先頭行, 1:最終行, 2:中間行

#DIM  nPosX
#DIM  nSizeW
#DIM  nSizeH
#DIM  nLineWidth

#DIM  nLoop
#DIMS strBuf
#DIMS CONST strBGColor = "#000000"

nPosX      = m_arrWndPropN:nWndId:PropIdx_WndPosX
nSizeW     = m_arrWndPropN:nWndId:PropIdx_WndWidth
nSizeH     = m_arrWndPropN:nWndId:PropIdx_WndHeight
nLineWidth = m_arrWndPropN:nWndId:PropIdx_WndClientWidth

SIF nSizeW <= 0 || nSizeH <= 0
	RETURN
SIF (m_arrWndPropN:nWndId:PropIdx_WndBorder > 0) && (nSizeW < 4 || nSizeH < 2)
	RETURN

	; 枠の色
VARSET arrBorderColor, ""
IF (m_arrWndPropN:nWndId:PropIdx_WndBorder > 0)
		; 無効ウィンドウ / ウィンドウ枠の色 / それ以外
	IF (m_arrWndPropN:nWndId:PropIdx_WndDisabled == 1)
		arrBorderColor:0 '= strInvlidColorText
		arrBorderColor:1 '= "@/C@"
	ELSEIF (m_arrWndPropN:nWndId:PropIdx_WndBorderColorSet == 1)
		arrBorderColor:0 '= "@C:0x" + TOSTR( m_arrWndPropN:nWndId:PropIdx_WndBorderColor, "X6" ) + "@"
		arrBorderColor:1 '= "@/C@"
	ELSE
		VARSET arrBorderColor, ""
	ENDIF
ENDIF
	; 枠線のテキスト
VARSET arrBorderText, ""
CALL WndMgr_GetWndBorderText( m_arrWndPropN:nWndId:PropIdx_WndBorder, arrBorderText )

	; 行開始のテキスト
SELECTCASE m_arrWndPropN:nWndId:PropIdx_WndBorder
		; 枠無し
	CASE 0
		arrWndText_LineStartText:0 '= @"<font face='ＭＳ ゴシック'><nonbutton pos='{(nPosX-1) * 50}'> </nonbutton></font>"
		arrWndText_LineStartText:1 '= @"<font face='ＭＳ ゴシック'><nonbutton pos='{(nPosX-1) * 50}'> </nonbutton></font>"
		arrWndText_LineStartText:2 '= @"<font face='ＭＳ ゴシック'><nonbutton pos='{(nPosX-1) * 50}'> </nonbutton></font>"
		; 枠あり
	CASE 1, 2
		LOCALS:0 '= FuncTagSetText_ConvHtmlText( arrBorderColor:0 + arrBorderText:0 + arrBorderColor:1 )
		LOCALS:1 '= FuncTagSetText_ConvHtmlText( arrBorderColor:0 + arrBorderText:3 + arrBorderColor:1 )
		LOCALS:2 '= FuncTagSetText_ConvHtmlText( arrBorderColor:0 + arrBorderText:6 + arrBorderColor:1 )
		arrWndText_LineStartText:0 '= @"<font face='ＭＳ ゴシック'><nonbutton pos='{nPosX * 50}'>%LOCALS:0%</nonbutton></font>"
		arrWndText_LineStartText:1 '= @"<font face='ＭＳ ゴシック'><nonbutton pos='{nPosX * 50}'>%LOCALS:1%</nonbutton></font>"
		arrWndText_LineStartText:2 '= @"<font face='ＭＳ ゴシック'><nonbutton pos='{nPosX * 50}'>%LOCALS:2%</nonbutton></font>"
ENDSELECT

	;--------------------------------
	; テキスト部
	;--------------------------------
	; 登録テキストを整形
VARSET arrWndTextBuf, ""
FOR nLoop, 0, nSizeH
	arrWndTextBuf:nLoop '= m_arrWndText:nWndId:nLoop
NEXT
	; HTMLテキストに変換
FOR nLoop, 0, nSizeH
	IF m_arrWndPropN:nWndId:PropIdx_WndDisabled == 1
		strBuf '= strInvlidColorText + FuncTagSetText_GetPlainText( arrWndTextBuf:nLoop ) + "@/C@"
	ELSE
		strBuf '= arrWndTextBuf:nLoop
			; ウィンドウが他のウィンドウの背後にある場合
		IF m_arrWndPropN:nWndId:PropIdx_WndBehindWindow == 1
				; 画像描画を無効にする
			WHILE 1
				LOCAL:0 = STRFINDU( strBuf, "@I:", 0 )
				SIF LOCAL:0 < 0
					BREAK
				LOCAL:1 = STRFINDU( strBuf, "@", LOCAL:0 + 1 )
				strBuf '= SUBSTRINGU( strBuf, LOCAL:0, LOCAL:1 - LOCAL:0 + 1 )
				LOCAL:0 = STRFINDU( strBuf, "@/I@", 0 )
				strBuf '= SUBSTRINGU( strBuf, LOCAL:0, 4 )
			WEND
		ENDIF
	ENDIF
	arrWndTextBuf:nLoop '= FuncTagSetText_ConvHtmlText( strBuf )
NEXT
	; 枠線ありの場合の特殊な処理
SELECTCASE m_arrWndPropN:nWndId:PropIdx_WndBorder
		; 枠無し
	CASE 0
		; 太枠, 細枠
	CASE 1, 2
			; テキスト位置を1行下にずらす
		ARRAYSHIFT arrWndTextBuf, 1, ""

			; 先頭行
		LOCALS:0 '= FuncTagSetText_ConvHtmlText( arrBorderColor:0 + arrBorderText:0 + arrBorderText:1 * (nLineWidth / 2) + arrBorderText:2 + arrBorderColor:1 )
		arrWndTextBuf:0 += @"<font face='ＭＳ ゴシック'><nonbutton pos='{nPosX * 50}'>%LOCALS:0%</nonbutton></font>"
			;	先頭行の追加記述：タイトル
		IF STRLENS( m_arrWndTitle:nWndId:0 ) > 0
			LOCAL:0   = (nPosX + 2) * 50
			LOCALS:0 '= FuncTagSetText_ConvHtmlText( arrBorderColor:0 + FuncTagSetText_GetPlainText( m_arrWndTitle:nWndId:0 ) + arrBorderColor:1 )
			LOCAL:1   = STRLENS( FuncTagSetText_GetPlainText( m_arrWndTitle:nWndId:0 ) )
			LOCALS:1 '= @"<shape type='rect' param='0,0,{LOCAL:1 * 50},100' color='%strBGColor%' bcolor='%strBGColor%'>"
			arrWndTextBuf:0 += @"<nonbutton pos='{LOCAL:0}'>%LOCALS:1%</nonbutton><nonbutton pos='{LOCAL:0}'>%LOCALS:0%</nonbutton>"
		ENDIF

			; 最終行
		LOCALS:0 '= FuncTagSetText_ConvHtmlText( arrBorderColor:0 + arrBorderText:3 + arrBorderText:4 * (nLineWidth / 2) + arrBorderText:5 + arrBorderColor:1 )
		arrWndTextBuf:(nSizeH - 1) += @"<font face='ＭＳ ゴシック'><nonbutton pos='{nPosX * 50}'>%LOCALS:0%</nonbutton></font>"
			;	最終行の追加記述：ログ表示ボタン
		IF m_arrWndPropN:nWndId:PropIdx_WndLogButton == 1
			LOCAL = (nPosX + MAX(0, nLineWidth - 16)) * 50
			arrWndTextBuf:(nSizeH - 1) += @"<button value='l' pos='{LOCAL}'> [l] ログ表示 </button>"
		ENDIF

			; 中間行
		FOR nLoop, 1, nSizeH - 1
			LOCAL = (nPosX + nSizeW - 2) * 50
			LOCALS:0 '= FuncTagSetText_ConvHtmlText( arrBorderColor:0 + arrBorderText:7 + arrBorderColor:1 )
			arrWndTextBuf:nLoop += @"<font face='ＭＳ ゴシック'><nonbutton pos='{LOCAL}'>%LOCALS:0%</nonbutton></font>"
		NEXT

ENDSELECT

	;--------------------------------
	; 表示テキストに登録
	;--------------------------------
	; ウィンドウ背景を塗りつぶす
LOCALS:0 '= @"<button pos='{nPosX * 50}' value='%m_strWndBgBtnValue%'>"
LOCALS:1 '= @"<shape type='rect' param='0,0,{nSizeW *50},100' color='%strBGColor%' bcolor='%strBGColor%'>"
LOCALS:2 '= @"</button>"
FOR nLoop, 0, nSizeH
	m_arrWndTextPrint:nWndId:nLoop '= @"%LOCALS:0%%LOCALS:1%%LOCALS:2%"
	;m_arrWndTextPrint:nWndId:nLoop '= @"<font face='ＭＳ ゴシック'><button pos='{nPosX * 50}' value='%m_strWndBgBtnValue%'>" + (" " * nSizeW) + LOCALS:0 + @"</button></font>"
	;	m_arrWndTextPrint:nWndId:nLoop '= @"<font face='ＭＳ ゴシック'><nonbutton pos='{nPosX * 50}'>" + (" " * nSizeW) + @"</nonbutton></font>"
		;MEMO ウィンドウ背景の塗り潰しだが、上と下どちらの処理もデメリットがある
		;     ・上の処理 ： ウィンドウ領域をクリックすると、文字入力が発生してしまう（INPUTSをぬけてしまう）。
		;     ・下の処理 ： ウィンドウが重なっている場合、上のウィンドウで隠れている、下のウィンドウのボタンを押下できてしまう。
		;     上の処理を採用する。理由は、入力内容が分かり、入力破棄と再入力で回避が可能で、予期せぬ入力が発生する下の処理よりも危険が少ないため。
NEXT
	; 変換したHTMLテキストを格納
FOR nLoop, 0, nSizeH
	SELECTCASE nLoop
		CASE 0
			m_arrWndTextPrint:nWndId:nLoop += arrWndText_LineStartText:0 + arrWndTextBuf:nLoop
		CASE nSizeH - 1
			m_arrWndTextPrint:nWndId:nLoop += arrWndText_LineStartText:1 + arrWndTextBuf:nLoop
		CASEELSE
			m_arrWndTextPrint:nWndId:nLoop += arrWndText_LineStartText:2 + arrWndTextBuf:nLoop
	ENDSELECT
NEXT

RETURN


;================================================================
;【内部処理用】
; 実際に表示する整形済みのテキストを作成する
;--------------------------------
;[引数]
;	nWndId						: ウィンドウＩＤ（0～9を指定する）
;--------------------------------
;================================================================
@WndMgr_CreatePrintText_Print( nWndId )
#DIM  nWndId

#DIMS arrWndTextBuf, 100

#DIMS arrBorderText, 8		; 左上, 上, 右上, 左下, 下, 右下, 左, 右, 
#DIMS arrBorderColor, 2
#DIMS strInvlidColorText = "@C:0x333333@"

#DIM  nPosX
#DIM  nSizeW
#DIM  nSizeH
#DIM  nLineWidth

#DIM  nLoop
#DIMS strBuf

nPosX      = m_arrWndPropN:nWndId:PropIdx_WndPosX
nSizeW     = m_arrWndPropN:nWndId:PropIdx_WndWidth
nSizeH     = m_arrWndPropN:nWndId:PropIdx_WndHeight
nLineWidth = (m_arrWndPropN:nWndId:PropIdx_WndBorder == 0 ? m_arrWndPropN:nWndId:PropIdx_WndWidth # m_arrWndPropN:nWndId:PropIdx_WndClientWidth)

SIF nSizeW <= 0 || nSizeH <= 0
	RETURN

	;--------------------------------
	; 枠線部
	;--------------------------------
	; 枠の色
VARSET arrBorderColor, ""
IF (m_arrWndPropN:nWndId:PropIdx_WndBorder > 0)
		; 無効ウィンドウ / ウィンドウ枠の色 / それ以外
	IF (m_arrWndPropN:nWndId:PropIdx_WndDisabled == 1)
		arrBorderColor:0 '= strInvlidColorText
		arrBorderColor:1 '= "@/C@"
	ELSEIF (m_arrWndPropN:nWndId:PropIdx_WndBorderColorSet == 1)
		arrBorderColor:0 '= "@C:0x" + TOSTR( m_arrWndPropN:nWndId:PropIdx_WndBorderColor, "X6" ) + "@"
		arrBorderColor:1 '= "@/C@"
	ELSE
		VARSET arrBorderColor, ""
	ENDIF
ENDIF
	; 枠線のテキスト
VARSET arrBorderText, ""
CALL WndMgr_GetWndBorderText( m_arrWndPropN:nWndId:PropIdx_WndBorder, arrBorderText )
IF (m_arrWndPropN:nWndId:PropIdx_WndBorder > 0)
	arrBorderText:0 '= arrBorderColor:0 + arrBorderText:0 + arrBorderColor:1
	arrBorderText:2 '= arrBorderColor:0 + arrBorderText:2 + arrBorderColor:1
	arrBorderText:3 '= arrBorderColor:0 + arrBorderText:3 + arrBorderColor:1
	arrBorderText:5 '= arrBorderColor:0 + arrBorderText:5 + arrBorderColor:1
	arrBorderText:6 '= arrBorderColor:0 + arrBorderText:6 + arrBorderColor:1
	arrBorderText:7 '= arrBorderColor:0 + arrBorderText:7 + arrBorderColor:1
ENDIF

	;--------------------------------
	; ウィンドウにセットされたテキストを整形
VARSET arrWndTextBuf, ""
FOR nLoop, 0, nSizeH
	arrWndTextBuf:nLoop '= m_arrWndText:nWndId:nLoop
NEXT
SELECTCASE m_arrWndPropN:nWndId:PropIdx_WndBorder
		; 枠無し
	CASE 0
		; 太枠, 細枠
	CASE 1, 2
		VARSET LOCALS, ""
		ARRAYSHIFT arrWndTextBuf, 1, ""
		LOCALS:0 '= FuncTagSetText_GetPlainText( m_arrWndTitle:nWndId:0 )
		LOCALS:1 '= arrBorderText:1 * (nLineWidth / 2)
		LOCALS:2 '= arrBorderText:4 * (nLineWidth / 2)
		IF m_arrWndPropN:nWndId:PropIdx_WndLogButton == 1
			LOCALS:3 '= " @B:l@\[l\] ログ表示@/B@ "
			LOCAL = FuncTagSetText_GetPrintLength( LOCALS:3 )
			LOCALS:2 '= FuncString_Mold( LOCALS:2, nLineWidth - LOCAL, " ", "L" )
		ENDIF
		arrWndTextBuf:0            '= arrBorderColor:0 + FuncString_Mold( LOCALS:0 + LOCALS:1, nLineWidth, " ", "L" ) + arrBorderColor:1
		arrWndTextBuf:(nSizeH - 1) '= arrBorderColor:0 + LOCALS:2 + LOCALS:3 + arrBorderColor:1
ENDSELECT

FOR nLoop, 0, nSizeH
	IF m_arrWndPropN:nWndId:PropIdx_WndDisabled == 1
		strBuf '= strInvlidColorText + FuncTagSetText_GetPlainText( arrWndTextBuf:nLoop ) + "@/C@"
	ELSE
		strBuf '= arrWndTextBuf:nLoop
	ENDIF
	arrWndTextBuf:nLoop '= TAG_PRINT_SHAPE( strBuf, nLineWidth, 1 )
NEXT

	;--------------------------------
	; テキスト部
SELECTCASE m_arrWndPropN:nWndId:PropIdx_WndBorder
		; 枠無し
	CASE 0
		FOR nLoop, 0, nSizeH
			m_arrWndTextPrint:nWndId:nLoop '= arrBorderText:6 + arrWndTextBuf:nLoop + arrBorderText:7
		NEXT

		; 枠あり, 細枠
	CASE 1, 2
		FOR nLoop, 0, nSizeH
			SELECTCASE nLoop
				CASE 0
					m_arrWndTextPrint:nWndId:nLoop '= arrBorderText:0 + arrWndTextBuf:nLoop + arrBorderText:2
				CASE nSizeH - 1
					m_arrWndTextPrint:nWndId:nLoop '= arrBorderText:3 + arrWndTextBuf:nLoop + arrBorderText:5
				CASEELSE
					m_arrWndTextPrint:nWndId:nLoop '= arrBorderText:6 + arrWndTextBuf:nLoop + arrBorderText:7
			ENDSELECT
		NEXT
ENDSELECT

RETURN


;================================================================
;【内部処理用】
; ウィンドウの枠線用テキストを取得する
;--------------------------------
;[引数]
;	nBorderType				: 枠線のタイプ
;	arrBorderText:Ｘ		: (REF) 枠線用テキスト格納領域（Ｘ:左上, 上, 右上, 左下, 下, 右下, 左, 右, ）
;--------------------------------
;================================================================
@WndMgr_GetWndBorderText( nBorderType, arrBorderText )
#DIM  nBorderType
#DIMS REF arrBorderText, 0

SELECTCASE nBorderType
		; 枠無し
	CASE 0
		VARSET arrBorderText, ""
		; 太枠
	CASE 1
		arrBorderText '= "┏", "━", "┓", "┗", "━", "┛", "┃", "┃"
		; 細枠
	CASE 2
		arrBorderText '= "┌", "─", "┐", "└", "─", "┘", "│", "│"
ENDSELECT

RETURN


;================================================================







