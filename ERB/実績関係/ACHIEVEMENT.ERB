; 実績の表示
@PRINT_ACHIEVEMENT
; 変数の定義と初期化
; LOCAL			カウンタなどの完全な一時変数 (要素数2)
; LIST			存在する実績番号を格納する変数 (要素数50)
; ACHIEVEMENT	達成条件の判定結果を格納する変数 (要素数50)
; PAGE			現在の表示ページ番号を格納する変数 (要素数1)
; PAGE_END		ページ番号の最大値を格納する変数 (要素数1)
#LOCALSIZE 2
#DIM LIST, MAX_ACHIEVEMENT
#DIM PAGE
#DIM PAGE_END
VARSET LIST, -1
VARSET ACHIEVEMENT, 0
; グローバル読み込み
LOADGLOBAL
; 関数の存在判定
LOCAL:1 = 0
FOR LOCAL, 0, MAX_ACHIEVEMENT
	; 関数の存在チェック
	; 存在する実績タイトルを戻す関数の番号をリスト変数に格納し、
	; リストの要素番号を格納するカウンタ変数をインクリメントする
	; 存在しない場合は次のループへ移る
	TRYCCALLFORM ACHIEVEMENT_TITLE_{LOCAL}
		LIST:(LOCAL:1) = LOCAL
		; タイトルが存在するなら引き続き実績の達成条件を判定
		ACHIEVEMENT:(LOCAL) = GLOBAL:(LOCAL)
		LOCAL:1++
	CATCH
		CONTINUE
	ENDCATCH
NEXT
; ページ終端を計算
PAGE_END = LOCAL:1 / 10
; グローバルのセーブ
; ここからリスト表示処理
$ACHIEVE_LIST
; リストヘッダーの表示
DRAWLINE
PRINTFORML %CALLNAME:MASTER%のこれまでの活動実績 page[{PAGE + 1}/{PAGE_END + 1}]
DRAWLINE
; リスト本体の表示
FOR LOCAL, PAGE * 10, PAGE * 10 + 10
	; リスト終端ならループ終了
	SIF LIST:LOCAL < 0
		BREAK
	; 達成条件判定とリスト描画処理
	IF ACHIEVEMENT:(LIST:LOCAL)
		CALLFORM ACHIEVEMENT_TITLE_{LIST:LOCAL}
		PRINTFORML  [{LOCAL, 2}] - %RESULTS%
	ELSE
		CALLFORM ACHIEVEMENT_HINT_{LIST:LOCAL}
		PRINTFORML  [ -] - %RESULTS%
	ENDIF
NEXT
PRINTL 
; リストフッターの表示
CALL PRINT_PAGE_NAVI(PAGE > 0,PAGE < PAGE_END)
PRINTL 
; ここから入力処理
$INPUT_LOOP
INPUT
IF RESULT == COMMAND_PREV_PAGE && PAGE > 0
	PAGE--
	GOTO ACHIEVE_LIST
ELSEIF RESULT == COMMAND_GO_BACK
	RETURN
ELSEIF RESULT == COMMAND_NEXT_PAGE && PAGE < PAGE_END
	PAGE++
	GOTO ACHIEVE_LIST
ELSEIF RESULT < 100 && ACHIEVEMENT:(LIST:RESULT)
	CALLFORM ACHIEVEMENT_MAIN_{LIST:RESULT}
	PRINTL 
	GOTO ACHIEVE_LIST
ELSE
	CLEARLINE 1
	REUSELASTLINE 無効な数値の入力です
	GOTO INPUT_LOOP
ENDIF

; 難易度チェック式中関数
@DIFFICULTY_CHECK
#FUNCTION
RETURNF FLAG:難易度 > 1 && !FLAG:EASYモードを経由したデータ

;毎ターン勝手に実績達成がチェックされるようにする
;知らない間に逃していた、は嫌なので
@CHECK_ACHIEVEMENT

SIF !DIFFICULTY_CHECK()
	RETURN

VARSET ACHIEVEMENT_PROGRESS, 0

LOADGLOBAL
FOR LOCAL, 0, MAX_ACHIEVEMENT
	IF !GLOBAL:(LOCAL)
		TRYCALLFORM ACHIEVEMENT_CALC_{LOCAL}
		SIF	GLOBAL:(LOCAL)
			BASE:MASTER:メダル++
	ENDIF
NEXT
